<!DOCTYPE html>
<html lang="en">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Boostrap CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css"
        integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">
    <script src="./js/libs/vue.min.js"></script>
    <script type="text/javascript" src="./eel.js"></script>

    <title>BJL模擬</title>

    <style>
        .card-holder {
            width: 100%;
            height: auto;
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            /* justify-content: center; */
            /* align-items: center; */
        }

        .card {
            width: 5%;
            height: auto;
        }

        .card-image {
            width: 100%;
            height: auto;
        }

        .button-holder {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 1rem 0;
        }

        .page-btn {
            margin: 0 0.2rem;
        }

        .road-holder {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
    </style>
</head>

<body>
    <nav class="navbar navbar-expand navbar-dark bg-dark">
        <a class="navbar-brand" href="#">百家樂模擬</a>
    </nav>
    <div id="app" class="container-fluid" style="margin-top: 20px;">

        <!-- <div class="row" style="margin: 20px 0;">
            <div class="col-1">
                <button id="shuffled" class="btn btn-primary" v-on:click="getData">模擬大路</button>
            </div>
        </div> -->

        <div class="row" style="margin: 20px 0;">
            <div class="col-1" style="margin-right: 0; padding-right: 0">
                <input v-model="cutPosition" type="text" id="cutPosition" class="form-control" placeholder="切牌位置 2~415"
                    v-on:keyup.enter="getRoad">
            </div>
            <div class="col-1">
                <button id="starts" class="btn btn-primary" v-on:click="getData">模擬大路</button>
            </div>
        </div>


        <div v-if="!isLoading" id="container">

            <div class="card-holder">

            </div>

            <!-- <div class="card-holder">
                <div v-for="(card, index) in showedCard" :key="index" class="card">
                    <img class="card-img" :src=`./image/${card}.png`> </div> </div> <div class="button-holder">
                    <button type="button" class="btn btn-primary btn-sm page-btn"
                        v-on:click="()=>{this.showedPage=0}">1</button>
                    <button type="button" class="btn btn-primary btn-sm page-btn"
                        v-on:click="()=>{this.showedPage=1}">2</button>
                    <button type="button" class="btn btn-primary btn-sm page-btn"
                        v-on:click="()=>{this.showedPage=2}">3</button>
                    <button type="button" class="btn btn-primary btn-sm page-btn"
                        v-on:click="()=>{this.showedPage=3}">4</button>
                    <button type="button" class="btn btn-primary btn-sm page-btn"
                        v-on:click="()=>{this.showedPage=4}">5</button>
                </div>
                <div class="road-holder">
                    <svg id="roadmap" width="1600" height="800"></svg>

                </div>

            </div> -->

        </div>

        <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"
            integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous">
        </script>
        <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"
            integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous">
        </script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js"
            integrity="sha384-w1Q4orYjBQndcko6MimVbzY0tgp4pWB4lZ7lr30WKz0vr/aWKhXdBNmNb5D92v7s" crossorigin="anonymous">
        </script>
        <script src="./js/libs/d3.min.js"></script>
        <script>
            var app = new Vue({
                el: '#app',
                data: {
                    isLoading: true,
                    roads: [],
                    cardCollect: [],
                    roundCollect: [],
                    resultCollect: [],
                    totalPage: 5,
                    showedPage: 1,
                    showedCard: [],
                    cutPosition: null,
                    cutTriggered: false,
                    chart: [],

                },
                methods: {
                    getData: function () {
                        console.log('getData');
                        let self = this;
                        isLoading = true
                        cut = self.cutPosition !== "" ? Number(self.cutPosition):null;

                        for (var i=0; i<10; i++){
                            eel.getRoad(cut)()
                                .then( res => {
                                    roads.append(res)
                                })

                        }
                        eel.getRoad(20)()
                            .then(res => {
                                roads.append(res)
                            })
                            .catch(error => {
                                console.log(error)
                            })
                            .finally(() => {
                                self.isLoading = false
                            })
                    },
                    getRoad: function () {
                        let self = this;
                        cpp = self.cutPosition !== "" ? Number(self.cutPosition) : null;

                        eel.cutCards(cpp, self.cardCollect)()
                            .then(res => {
                                this.roundCollect = res[0];
                                this.resultCollect = res[1];
                            })
                            .catch(error => {
                                console.log(error);
                            })
                            .finally(() => {
                                self.cutTriggered = true;
                            })
                    },
                    calGoodRoad: function () {
                        let self = this;
                        var rc = JSON.parse(JSON.stringify(self.resultCollect));

                        // remove all "和" from rc
                        // "和" won't affect good roads
                        rc = rc.filter(ele => ele !== "和")

                        // good road
                        var longB = 0 // 長庄
                        var longP = 0 // 長閑
                        var singleJump = 0 // 大路單跳
                        var doubleJump = 0 // 大路雙跳
                        var playerJump = 0 // 逢閑跳
                        var oPtB = 0 // 一廳兩房(庄)
                        var oBtP = 0 // 一廳兩房(閑)
                        var bankerJump = 0 // 逢閑跳
                        var ppz = 0 // 拍拍黐
                        var sqRoad = 0

                        var bankers = []
                        var players = []

                        var currRecord = rc.shift()
                        var prevRecord
                        var success = 1

                        while (rc.length > 0) {
                            prevRecord = currRecord
                            currRecord = rc.shift()

                            if (currRecord === prevRecord) {
                                success += 1
                            } else {
                                if (prevRecord === "庄") {
                                    bankers.push(success)
                                } else {
                                    players.push(success)
                                }
                                success = 1
                            }
                        }
                        d

                        longB = bankers.filter(ele => ele >= 4).length
                        longP = players.filter(ele => ele >= 4).length

                        console.log({
                            '長庄': longB,
                            '長閑': longP,
                        })

                        var bankerJumpCheck = 0
                        var playerJumpCheck = 0

                        //計算逢庄跳
                        for (var i = 0; i < bankers.length; i++) {
                            if (bankers[i] !== 1) {
                                bankerJumpCheck = 0
                            } else {
                                bankerJumpCheck += 1
                            }

                            if (bankerJumpCheck === 3) {
                                bankerJump += 1
                            }
                        }

                        // 計算逢閑跳
                        for (var i = 0; i < players.length; i++) {

                            if (players[i] !== 1) {
                                playerJumpCheck = 0
                            } else {
                                playerJumpCheck += 1
                            }

                            if (playerJumpCheck === 3) {
                                playerJump += 1
                            }
                        }

                        console.log({
                            '逢閑跳': playerJump,
                            '逢庄跳': bankerJump
                        })

                        var singleJumpCheck = 0
                        var doubleJumpCheck = 0

                        // 計算大路單跳 & 大路雙跳
                        targetLength = Math.max(bankers.length, players.length)

                        var bankerPrev = 0
                        var playerPrev = 0

                        n = 0

                    },
                    reCalRoad: function () {
                        let self = this;
                        // 深複製 resultCollect -> 避免 watch 產生無限迴圈 
                        var rc = JSON.parse(JSON.stringify(self.resultCollect));

                        // x 從 1 開始
                        // y 從 1 開始
                        // maxX 紀錄 長龍數
                        // maxY 紀錄高 長龍
                        var currX = 1
                        var currY = 1
                        var maxY = 1
                        var result = []

                        // 取得第一個 不是和
                        var firstNotEven = rc.filter(d => d !== "和")[0]

                        // 取出第一個結果
                        var currRecord = rc.shift()

                        var tempRecord = {
                            x: currX,
                            y: maxY,
                            result: currRecord,
                            fill: currRecord === "閑" ? "red" : currRecord === "庄" ? "blue" : "green"
                        }

                        result.push(tempRecord)

                        // 避免第一個結果是 “和”
                        // 先指定為第一個非和的值
                        if (currRecord === "和") {
                            currRecord = firstNotEven
                        }

                        while (rc.length > 0) {
                            // 紀錄 上一個 值
                            var prevRecord = currRecord
                            var currRecord = rc.shift()

                            // 如果 prevRecord !== currRecord
                            if (prevRecord !== currRecord && currRecord !== '和') {
                                currX += 1
                                if (currY > maxY) {
                                    maxY = currY
                                }
                                currY = 1
                            } else {
                                // prevRecord === currRecord or currRecord === "和"
                                // currY += 1
                                currY += 1
                            }

                            tempRecord = {
                                x: currX,
                                y: currY,
                                result: currRecord,
                                fill: currRecord === "閑" ? "red" : currRecord === "庄" ? "blue" : "green"
                            }

                            result.push(tempRecord)

                            if (currRecord === "和") {
                                currRecord = prevRecord
                            }

                        }

                        return {
                            maxX: currX,
                            maxY: maxY,
                            result: result
                        }

                    },
                    plotRoad: function (rc) {
                        console.log("plot data triggered")
                        let self = this;

                        const xAxisRange = [...Array(rc.maxX).keys()];
                        const yAxisRange = [...Array(rc.maxY).keys()];

                        const margin = {
                            top: 20,
                            right: 20,
                            bottom: 20,
                            left: 30
                        }

                        const circleR = 12

                        const width = 1200;
                        const height = 800;

                        const innerWidth = width - margin.left - margin.right;
                        const innerHeight = height - margin.top - margin.bottom;

                        const svg = d3.select(`#roadmap`);

                        svg.selectAll("*").remove();

                        self.chart = svg.append('g')
                            .attr('transform', `translate(${margin.left}, 0)`);

                        const roads = svg.selectAll('roadCell')
                            .data(rc.result)
                            .enter().append('circle')
                            .attr('cx', d => (d.x + 1) * circleR * 2)
                            .attr('cy', d => (d.y + 1) * circleR * 2)
                            .attr('r', circleR)
                            .style('fill', d => d.fill)
                            .style('stroke', 'solid')
                            .style('stroke-color', d => d.fill);

                        // create table grids
                        const tableGrid = []
                        for (var i = 1; i < rc.maxX + 1; i++) {
                            for (var j = 1; j < rc.maxY + 1; j++) {
                                tableGrid.push({
                                    x: i,
                                    y: j
                                })
                            }
                        }

                        const squares = svg.selectAll('sqCell')
                            .data(tableGrid)
                            .enter().append('rect')
                            .attr('x', d => (d.x + 0.5) * circleR * 2)
                            .attr('y', d => (d.y + 0.5) * circleR * 2)
                            .attr('width', circleR * 2)
                            .attr('height', circleR * 2)
                            .style('fill', "None")
                            .style('stroke', 'black')
                            .style('stroke-widht', '1px')


                    }

                },
                compute: {

                },
                mounted: function () {
                    // document.getElementById('cutPosition').addEventListener('keyup', function (event) {
                    //     event.preventDefault();
                    //     if (event.keyCode === 13) {
                    //         document.getElementById("starts").click();
                    //     }
                    // })
                },
                watch: {
                    cardCollect: function (cards) {
                        this.showedPage = 1
                        this.showedCard = cards.slice(0, 100)
                    },
                    showedPage: function (page) {
                        this.showedCard = this.cardCollect.slice(page * 100, page * 100 + 100)
                    },
                    resultCollect: function (val) {
                        if (val) {
                            // 重新計算大路座標, 並畫圖
                            this.plotRoad(this.reCalRoad());
                            // 重新計算好路統計
                            this.calGoodRoad();
                        }
                    }

                }

            })
        </script>



</body>

</html>